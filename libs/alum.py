import requests
from dataclasses import dataclass
from functools import lru_cache
from typing import Dict, List

# SessionId/CSRF token might need to be re-generated by hand :( not sure
# This very well might be sending requests through my LinkedIn account
# which would be unfortunate and spammy, but oh well. 
REQUEST_COOKIES = {
    "JSESSIONID": '"ajax:1458873444599991598"',
    "li_at": "AQEDAS0McIsD4L9MAAABfC-jtigAAAGAdtjLGU4AontSTVq1ogxaEa1dv7fwCgLBoWIUWlpOHhiZFsCjB6Y2NFWa7KYaVlYfMa1jLSTsBQZEskVSNuJGLNvyCD1GlhXNW7YiiBsk9tbcGtDSIMJ_bv4Z",
}
REQUEST_HEADERS = {"csrf-token": "ajax:1458873444599991598"}


@dataclass(frozen=True)
class Alum:
    """Personal data pulled from an Alum's LinkedIn page."""

    id: str
    name: str
    company: str
    title: str
    url: str
    # TODO: find a good request to grab graduation year from.

    @classmethod
    def from_id(self, id: str) -> "Alum":
        # I envisioned these being class properties but dataclasses asdict()
        # does not recognize properties for serialization :( solving that would
        # make this neater, and we could turn the helpers functions into methods.
        url = f"https://linkedin.com/in/{id}"
        company = _parse_topline_company(id=id)
        title = _parse_identity_connection(id=id, identifier="headline")
        firstname = _parse_identity_connection(id=id, identifier="firstName")
        lastname = _parse_identity_connection(id=id, identifier="lastName")
        return Alum(
            id=id, url=url, name=f"{firstname} {lastname}", company=company, title=title
        )

    @classmethod
    def from_url(self, url: str) -> "Alum":
        # Light assumption that url is sanitary, e.g.
        # https://www.linkedin.com/in/user-id-123/
        id = url.split("linkedin.com/in/")[1].replace("/", "")
        return Alum.from_id(id=id)


# I really want these to be private methods of Alum, see above.
# TODO: explore linkedin requests/graphql to find cleaner, more precise queries.
@lru_cache
def _make_user_request(id: str, query_type: str = "memberIdentity"):
    params = {
        "q": query_type,
        "memberIdentity": id,
        "decorationId": "com.linkedin.voyager.dash.deco.identity.profile.TopCardSupplementary-93",
    }

    return requests.get(
        "https://www.linkedin.com/voyager/api/identity/dash/profiles",
        headers=REQUEST_HEADERS,
        params=params,
        cookies=REQUEST_COOKIES,
    ).json()


def _parse_topline_company(id: str):
    payload = _make_user_request(id=id)["elements"][0]
    return payload["profileTopPosition"]["elements"][0]["multiLocaleCompanyName"][
        "en_US"
    ]


def _parse_identity_connection(id: str, identifier: str):
    """Parse the overflowAction.connection object for a given key/value pair

    Only works for keys nested a certain distance within 'connection', so this is fragile.
    """
    payload = _make_user_request(id=id)["elements"][0]
    overflow_actions: List[Dict] = payload["profileProfileActions"]["overflowActions"]
    # Assume there is only one element with the key "connection"
    connection = [
        obj for obj in overflow_actions if obj.get("connection", None) is not None
    ][0]["connection"]

    return connection["memberRelationship"]["memberRelationshipUnion"]["connection"][
        "connectedMemberResolutionResult"
    ][identifier]
